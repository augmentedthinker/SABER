<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Saber's Dice Vault</title>
    <style>
        body {
            margin: 0; padding: 0;
            background-color: #0a0a0a; color: #e0e0e0;
            font-family: 'Inter', -apple-system, sans-serif;
            display: flex; justify-content: center; align-items: center;
            height: 100vh; overflow: hidden;
            background: radial-gradient(circle at center, #1a1a1a 0%, #050505 100%);
        }
        .dice-widget {
            width: 90vw; max-width: 380px; height: 550px;
            background: #151515; border-radius: 28px; border: 1px solid #333;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.9);
            display: flex; flex-direction: column; overflow: hidden; position: relative;
        }
        #canvas-container { flex: 1; width: 100%; background: #000; position: relative; }
        .result-overlay { position: absolute; top: 20px; width: 100%; text-align: center; pointer-events: none; z-index: 5; }
        .total-number {
            font-size: 4rem; font-weight: 900; color: #00ffcc;
            text-shadow: 0 0 20px rgba(0, 255, 204, 0.6);
            opacity: 0; transform: scale(0.5);
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        .total-number.show { opacity: 1; transform: scale(1); }
        .controls {
            background: #1a1a1a; padding: 16px;
            display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px;
            border-top: 1px solid #333; z-index: 10;
        }
        .dice-btn {
            background: #252525; border: 1px solid #333; color: #aaa;
            padding: 10px 4px; border-radius: 12px; font-size: 0.75rem; font-weight: 700;
            cursor: pointer; display: flex; flex-direction: column; align-items: center;
        }
        .dice-btn:active { transform: scale(0.95); }
        .roll-btn {
            grid-column: span 3; background: #00ffcc; color: #000; border: none;
            padding: 14px; border-radius: 12px; font-weight: 900; font-size: 1rem;
            margin-top: 4px; cursor: pointer; text-transform: uppercase;
        }
        .clear-btn {
            position: absolute; top: 10px; right: 10px;
            background: rgba(255,255,255,0.1); border: none; color: #888;
            font-size: 0.6rem; padding: 5px 10px; border-radius: 20px; cursor: pointer; z-index: 6;
        }
    </style>
</head>
<body>
    <div class="dice-widget">
        <div class="result-overlay"><div id="result-total" class="total-number">0</div></div>
        <div id="canvas-container"><button class="clear-btn" onclick="clearDice()">RESET</button></div>
        <div class="controls">
            <button class="dice-btn" onclick="addDice('d4')">D4</button>
            <button class="dice-btn" onclick="addDice('d6')">D6</button>
            <button class="dice-btn" onclick="addDice('d8')">D8</button>
            <button class="dice-btn" onclick="addDice('d10')">D10</button>
            <button class="dice-btn" onclick="addDice('d12')">D12</button>
            <button class="dice-btn" onclick="addDice('d20')">D20</button>
            <button class="roll-btn" onclick="rollAll()">Roll Dice</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cannon@0.6.2/build/cannon.min.js"></script>

    <script>
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 100);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);

        camera.position.set(0, 10, 0);
        camera.lookAt(0, 0, 0);

        scene.add(new THREE.AmbientLight(0xffffff, 0.8));
        const light = new THREE.DirectionalLight(0xffffff, 0.5);
        light.position.set(5, 10, 2);
        light.castShadow = true;
        scene.add(light);

        const world = new CANNON.World();
        world.gravity.set(0, -30, 0);
        world.allowSleep = true;

        const diceMaterial = new CANNON.Material();
        const floorMaterial = new CANNON.Material();
        world.addContactMaterial(new CANNON.ContactMaterial(floorMaterial, diceMaterial, { friction: 0.1, restitution: 0.2 }));

        const floorBody = new CANNON.Body({ mass: 0, shape: new CANNON.Plane(), material: floorMaterial });
        floorBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
        world.addBody(floorBody);

        function createWall(x, y, z, rotX, rotY) {
            const body = new CANNON.Body({ mass: 0, shape: new CANNON.Plane(), material: floorMaterial });
            body.position.set(x, y, z);
            if (rotX) body.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), rotX);
            if (rotY) body.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), rotY);
            world.addBody(body);
        }
        createWall(3,0,0,0,-Math.PI/2); createWall(-3,0,0,0,Math.PI/2);
        createWall(0,0,4,0,Math.PI); createWall(0,0,-4,0,0);

        const diceList = [];
        const colors = [0x00ffcc, 0xff0066, 0x7000ff, 0xffcc00];

        // --- Improved Texture Generation ---
        function createTextMaterial(number, color) {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#' + color.toString(16).padStart(6, '0');
            ctx.fillRect(0, 0, 256, 256);
            ctx.fillStyle = 'white';
            ctx.font = 'bold 160px Arial';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(number, 128, 128);
            const texture = new THREE.CanvasTexture(canvas);
            return new THREE.MeshPhongMaterial({ map: texture });
        }

        // --- Manual Geometry Mapping ---
        function getDiceGeometry(type, color) {
            let geometry;
            let sides;
            switch(type) {
                case 'd4': geometry = new THREE.TetrahedronGeometry(1.2); sides = 4; break;
                case 'd6': geometry = new THREE.BoxGeometry(1.2, 1.2, 1.2); sides = 6; break;
                case 'd8': geometry = new THREE.OctahedronGeometry(1.2); sides = 8; break;
                case 'd10': geometry = new THREE.IcosahedronGeometry(1.2, 0); sides = 10; break;
                case 'd12': geometry = new THREE.DodecahedronGeometry(1.2); sides = 12; break;
                case 'd20': geometry = new THREE.IcosahedronGeometry(1.2); sides = 20; break;
            }

            // Convert to non-indexed so every face is unique
            geometry = geometry.toNonIndexed();
            const materialArray = [];
            const faceCount = geometry.attributes.position.count / 3;
            
            geometry.clearGroups();
            for (let i = 0; i < faceCount; i++) {
                const num = (i % sides) + 1;
                materialArray.push(createTextMaterial(num, color));
                geometry.addGroup(i * 3, 3, i);
            }
            
            // Fix UV mapping for textures to show centered on triangles/quads
            const uvs = geometry.attributes.uv.array;
            for (let i = 0; i < uvs.length; i += 6) {
                uvs[i] = 0.5; uvs[i+1] = 1;
                uvs[i+2] = 0; uvs[i+3] = 0;
                uvs[i+4] = 1; uvs[i+5] = 0;
            }
            geometry.attributes.uv.needsUpdate = true;

            return { geometry, materialArray, sides };
        }

        function addDice(type) {
            if (diceList.length >= 8) return;
            const color = colors[Math.floor(Math.random() * colors.length)];
            const data = getDiceGeometry(type, color);
            const mesh = new THREE.Mesh(data.geometry, data.materialArray);
            mesh.castShadow = true;
            mesh.userData.sides = data.sides;
            scene.add(mesh);

            const shape = (type === 'd6') ? new CANNON.Box(new CANNON.Vec3(0.6, 0.6, 0.6)) : new CANNON.Sphere(0.8);
            const body = new CANNON.Body({ mass: 1, shape: shape, material: diceMaterial });
            body.position.set(Math.random()-0.5, 5, Math.random()-0.5);
            body.linearDamping = 0.2; body.angularDamping = 0.2;
            world.addBody(body);
            diceList.push({ mesh, body });
        }

        function getResult(dice) {
            const mesh = dice.mesh;
            const geometry = mesh.geometry;
            const normalMatrix = new THREE.Matrix3().getNormalMatrix(mesh.matrixWorld);
            const position = geometry.attributes.position;
            
            let maxDot = -1;
            let topFaceIndex = 0;

            for (let i = 0; i < position.count; i += 3) {
                const vA = new THREE.Vector3().fromBufferAttribute(position, i);
                const vB = new THREE.Vector3().fromBufferAttribute(position, i+1);
                const vC = new THREE.Vector3().fromBufferAttribute(position, i+2);
                
                const normal = new THREE.Vector3().crossVectors(
                    new THREE.Vector3().subVectors(vC, vB),
                    new THREE.Vector3().subVectors(vA, vB)
                ).normalize().applyMatrix3(normalMatrix);

                const dot = normal.dot(new THREE.Vector3(0, 1, 0));
                if (dot > maxDot) {
                    maxDot = dot;
                    topFaceIndex = i / 3;
                }
            }
            return (topFaceIndex % mesh.userData.sides) + 1;
        }

        function rollAll() {
            if (diceList.length === 0) return;
            document.getElementById('result-total').classList.remove('show');
            diceList.forEach(d => {
                d.body.wakeUp();
                d.body.position.set(Math.random()*0.5, 6, Math.random()*0.5);
                d.body.velocity.set((Math.random()-0.5)*15, -15, (Math.random()-0.5)*15);
                d.body.angularVelocity.set(Math.random()*30, Math.random()*30, Math.random()*30);
            });
            setTimeout(() => {
                let total = 0;
                diceList.forEach(d => { total += getResult(d); });
                const el = document.getElementById('result-total');
                el.innerText = total;
                el.classList.add('show');
            }, 2000);
        }

        function clearDice() {
            diceList.forEach(d => { scene.remove(d.mesh); world.remove(d.body); });
            diceList.length = 0;
            document.getElementById('result-total').classList.remove('show');
        }

        function animate() {
            requestAnimationFrame(animate);
            world.step(1/60);
            diceList.forEach(d => {
                d.mesh.position.copy(d.body.position);
                d.mesh.quaternion.copy(d.body.quaternion);
            });
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
